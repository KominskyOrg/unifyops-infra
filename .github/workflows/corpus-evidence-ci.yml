name: corpus-evidence-ci

on:
  pull_request:
  push:
    branches:
      - dev
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      UO_EVIDENCE_CORPUS_SOURCE_REPO:
        description: 'Optional override for source repo (org/repo) used by corpus runner checkout.'
        required: false
        type: string
      UO_EVIDENCE_CORPUS_SOURCE_REF:
        description: 'Optional override for source ref (branch/tag/SHA) used by corpus runner checkout.'
        required: false
        default: 'e65ef29bc36ad65b641a903a6b23f488a95c3f3f'
        type: string

jobs:
  corpus-evidence:
    runs-on: ubuntu-latest
    env:
      CORPUS_ROOT: _deps/unifyops/evidence/validator/testdata/evidence-corpus
      CORPUS_OUTPUT_DIR: evidence/validator/test-output
      CORPUS_MATRIX: evidence/validator/test-output/corpus-matrix-report-v1.json
      CORPUS_SUMMARY: evidence/validator/test-output/corpus-summary.md
      CORPUS_REPORTS_DIR: evidence/validator/test-output/corpus-reports
      POLICY_OUTCOME_JSON: evidence/validator/test-output/policy-outcome-v1.json
      ARTIFACT_MANIFEST_JSON: evidence/validator/test-output/artifact-manifest-v1.json
      ARTIFACT_LINKAGE_OUTCOME_JSON: evidence/validator/test-output/artifact-linkage-outcome-v1.json
      REASON_CODES_INDEX_JSON: evidence/validator/test-output/reason-codes-index-v1.json
      POLICY_DRIFT_OUTCOME_JSON: evidence/validator/test-output/policy-drift-outcome-v1.json
      ENVELOPE_COHESION_OUTCOME_JSON: evidence/validator/test-output/envelope-cohesion-outcome-v1.json
      DETERMINISM_OUTCOME_JSON: evidence/validator/test-output/determinism-outcome-v1.json
      GOVERNANCE_SUMMARY_JSON: evidence/validator/test-output/governance-summary-v1.json
      GOVERNANCE_TRENDS_JSON: evidence/validator/test-output/governance-trends-v1.json
      ARTIFACT_SIGNATURES_JSON: evidence/validator/test-output/artifact-signatures-v1.json
      GOVERNANCE_DASHBOARD_JSON: evidence/validator/test-output/governance-dashboard-v1.json
      GOVERNANCE_TRENDS_PRIOR_DIR: evidence/validator/test-output/prior-trends
      GOVERNANCE_TRENDS_MAX_RUNS: ${{ vars.GOVERNANCE_TRENDS_MAX_RUNS || '20' }}
      GOVERNANCE_TRENDS_LOOKBACK_RUNS: ${{ vars.GOVERNANCE_TRENDS_LOOKBACK_RUNS || '5' }}
      # Release-controlled lanes: tag pipelines by default.
      RELEASE_CONTROLLED_LANE: ${{ startsWith(github.ref, 'refs/tags/') && 'true' || 'false' }}
      # Temporary rollout toggle (disabled by default).
      EVIDENCE_CORPUS_NON_BLOCKING: ${{ vars.EVIDENCE_CORPUS_NON_BLOCKING || 'false' }}
      EVIDENCE_CORPUS_NON_BLOCKING_OWNER: ${{ vars.EVIDENCE_CORPUS_NON_BLOCKING_OWNER || '' }}
      EVIDENCE_CORPUS_NON_BLOCKING_EXPIRY: ${{ vars.EVIDENCE_CORPUS_NON_BLOCKING_EXPIRY || '' }}
      EXPECTED_CORPUS_CASE_COUNT: ${{ vars.EXPECTED_CORPUS_CASE_COUNT || '' }}
      CORPUS_MANIFEST_PATH: ${{ vars.CORPUS_MANIFEST_PATH || '' }}
      EXPECTED_CORPUS_MANIFEST_SHA256: ${{ vars.EXPECTED_CORPUS_MANIFEST_SHA256 || '' }}
      UO_EVIDENCE_CORPUS_RUNNER_VERSION: "1.0.0"
      # Use source-of-truth runner code from unifyops repo to avoid drift in published packages.
      UO_EVIDENCE_CORPUS_SOURCE_REPO: ${{ inputs.UO_EVIDENCE_CORPUS_SOURCE_REPO || vars.UO_EVIDENCE_CORPUS_SOURCE_REPO || format('{0}/unifyops', github.repository_owner) }}
      UO_EVIDENCE_CORPUS_SOURCE_REF: ${{ inputs.UO_EVIDENCE_CORPUS_SOURCE_REF || vars.UO_EVIDENCE_CORPUS_SOURCE_REF || '' }}
      UO_EVIDENCE_CORPUS_DEFAULT_REF: ${{ vars.UO_EVIDENCE_CORPUS_DEFAULT_REF || 'e65ef29bc36ad65b641a903a6b23f488a95c3f3f' }}
      # Optional for cross-repo private checkout: set secret UO_EVIDENCE_SOURCE_TOKEN with read access.
      UO_EVIDENCE_SOURCE_TOKEN: ${{ secrets.UO_EVIDENCE_SOURCE_TOKEN || '' }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python for corpus runner
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Preflight source repo access/ref for corpus runner checkout
        id: source_preflight
        continue-on-error: true
        env:
          CURRENT_REPO: ${{ github.repository }}
          CURRENT_SHA: ${{ github.sha }}
          INPUT_SOURCE_REF: ${{ inputs.UO_EVIDENCE_CORPUS_SOURCE_REF || '' }}
          VAR_SOURCE_REF: ${{ vars.UO_EVIDENCE_CORPUS_SOURCE_REF || '' }}
          VAR_DEFAULT_REF: ${{ vars.UO_EVIDENCE_CORPUS_DEFAULT_REF || '' }}
        run: bash .ci/scripts/source_preflight.sh

      - name: Checkout unifyops source for corpus runner
        id: source_checkout
        if: always() && steps.source_preflight.outputs.preflight_ok == 'true'
        continue-on-error: true
        uses: actions/checkout@v4
        with:
          repository: ${{ env.UO_EVIDENCE_CORPUS_SOURCE_REPO }}
          ref: ${{ steps.source_preflight.outputs.effective_ref }}
          path: _deps/unifyops
          token: ${{ env.UO_EVIDENCE_CORPUS_SOURCE_REPO == github.repository && github.token || secrets.UO_EVIDENCE_SOURCE_TOKEN }}

      - name: Install evidence corpus runner dependency (local source)
        id: runner_install
        if: always() && steps.source_preflight.outputs.preflight_ok == 'true' && steps.source_checkout.outcome == 'success'
        continue-on-error: true
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install -e _deps/unifyops/shared/unifyops_core
          python -m pip install email-validator

      - name: Ensure corpus output directories exist
        run: mkdir -p "${CORPUS_OUTPUT_DIR}" "${CORPUS_REPORTS_DIR}"

      - name: Run evidence corpus runner (local source)
        id: corpus_runner
        if: always() && steps.source_preflight.outputs.preflight_ok == 'true' && steps.source_checkout.outcome == 'success' && steps.runner_install.outcome == 'success'
        continue-on-error: true
        run: |
          set -euo pipefail
          python -m unifyops_core.evidence.validator.tools.corpus_runner \
            --corpus-root "${CORPUS_ROOT}" \
            --matrix-out "${CORPUS_MATRIX}" \
            --reports-dir "${CORPUS_REPORTS_DIR}" \
            --summary-md-out "${CORPUS_SUMMARY}"

      - name: Enforce runner/matrix gate semantics
        if: always()
        env:
          PRECHECK_OUTCOME: ${{ steps.source_preflight.outcome }}
          PRECHECK_OK: ${{ steps.source_preflight.outputs.preflight_ok }}
          PRECHECK_ERROR_TYPE: ${{ steps.source_preflight.outputs.error_type }}
          PRECHECK_ERROR_MESSAGE: ${{ steps.source_preflight.outputs.error_message }}
          SOURCE_CHECKOUT_OUTCOME: ${{ steps.source_checkout.outcome }}
          RUNNER_INSTALL_OUTCOME: ${{ steps.runner_install.outcome }}
          RUNNER_OUTCOME: ${{ steps.corpus_runner.outcome }}
        run: |
          set -euo pipefail
          non_blocking="${EVIDENCE_CORPUS_NON_BLOCKING,,}"
          prereq_error=""

          if [[ "${PRECHECK_OK:-false}" != "true" ]]; then
            prereq_error="source checkout preflight failed (${PRECHECK_ERROR_TYPE:-unknown}): ${PRECHECK_ERROR_MESSAGE:-preflight did not succeed}"
          elif [[ "${SOURCE_CHECKOUT_OUTCOME:-skipped}" != "success" ]]; then
            prereq_error="source checkout step failed (outcome=${SOURCE_CHECKOUT_OUTCOME:-unknown})."
          elif [[ "${RUNNER_INSTALL_OUTCOME:-skipped}" != "success" ]]; then
            prereq_error="runner dependency install step failed (outcome=${RUNNER_INSTALL_OUTCOME:-unknown})."
          elif [[ "${RUNNER_OUTCOME:-skipped}" != "success" ]]; then
            prereq_error="corpus runner execution failed (outcome=${RUNNER_OUTCOME:-unknown})."
          fi

          if [[ -n "${prereq_error}" ]]; then
            if [[ "${non_blocking}" == "true" ]]; then
              echo "::warning::[NON-BLOCKING EVIDENCE CORPUS] ${prereq_error} Downstream validation is skipped."
            else
              echo "::error::Evidence corpus gate failed: ${prereq_error}"
              exit 1
            fi
          fi

          if [[ ! -s "${CORPUS_MATRIX}" ]]; then
            if [[ "${non_blocking}" == "true" ]]; then
              echo "::warning::[NON-BLOCKING EVIDENCE CORPUS] matrix artifact missing at ${CORPUS_MATRIX}; digest/lineage/policy validation is skipped."
            else
              echo "::error::Evidence corpus gate failed: required matrix artifact missing at ${CORPUS_MATRIX}."
              exit 1
            fi
          fi

      - name: Emit lineage, digests, and preflight summary
        id: lineage_digests
        if: always()
        env:
          GH_SHA: ${{ github.sha }}
          GH_RUN_ID: ${{ github.run_id }}
          GH_RUN_ATTEMPT: ${{ github.run_attempt }}
          SUMMARY_LANE: ${{ env.RELEASE_CONTROLLED_LANE }}
          SUMMARY_SOURCE_REPO: ${{ env.UO_EVIDENCE_CORPUS_SOURCE_REPO }}
          SUMMARY_SOURCE_REF: ${{ steps.source_preflight.outputs.effective_ref }}
          SUMMARY_REF_MODE: ${{ steps.source_preflight.outputs.ref_mode }}
          SUMMARY_PREFLIGHT_OK: ${{ steps.source_preflight.outputs.preflight_ok }}
          SUMMARY_LOCKFILE_PRESENT: ''
          SUMMARY_EXPECTED_CASE_COUNT_SOURCE: ''
        run: python3 .ci/scripts/emit_lineage.py

      - name: Evaluate lane-specific corpus evidence posture
        id: release_posture_policy
        if: always()
        env:
          PRECHECK_OK: ${{ steps.source_preflight.outputs.preflight_ok }}
          PRECHECK_ERROR_TYPE: ${{ steps.source_preflight.outputs.error_type }}
          PRECHECK_ERROR_MESSAGE: ${{ steps.source_preflight.outputs.error_message }}
          EFFECTIVE_REF: ${{ steps.source_preflight.outputs.effective_ref }}
          REF_MODE: ${{ steps.source_preflight.outputs.ref_mode }}
          REF_ORIGIN: ${{ steps.source_preflight.outputs.ref_origin }}
          LOCKFILE_PRESENT: ${{ steps.lineage_digests.outputs.lockfile_present }}
          LOCKFILE_PATH: ${{ steps.lineage_digests.outputs.lockfile_path }}
          SEARCHED_LOCKFILE_PATHS: ${{ steps.lineage_digests.outputs.searched_lockfile_paths }}
          SOURCE_MANIFEST_PATH: ${{ steps.lineage_digests.outputs.source_manifest_path }}
          SOURCE_MANIFEST_SHA256: ${{ steps.lineage_digests.outputs.source_manifest_sha256 }}
        run: |
          set -euo pipefail
          release_lane="${RELEASE_CONTROLLED_LANE,,}"

          if [[ "${release_lane}" == "true" ]]; then
            echo "::notice::[POLICY][RELEASE] enforcing immutable source ref + lockfile evidence requirements"
            failures=()

            if [[ "${PRECHECK_OK:-false}" != "true" ]]; then
              failures+=("RLP_REF_PREFLIGHT_FAILED|ref-integrity preflight failed (${PRECHECK_ERROR_TYPE:-unknown}): ${PRECHECK_ERROR_MESSAGE:-preflight did not succeed}")
            elif [[ "${REF_MODE:-mutable}" != "immutable" ]]; then
              failures+=("RLP_REF_NOT_IMMUTABLE|ref-integrity requires immutable source ref in release lane, got mode=${REF_MODE:-unset} ref='${EFFECTIVE_REF:-unset}'")
            else
              echo "::notice::[POLICY][RELEASE] ref-integrity satisfied: ref='${EFFECTIVE_REF}' origin='${REF_ORIGIN}' mode='${REF_MODE}'"
            fi

            if [[ "${LOCKFILE_PRESENT:-false}" != "true" || -z "${LOCKFILE_PATH}" ]]; then
              failures+=("RLP_LOCKFILE_REQUIRED|lockfile evidence required in release lane; none found (searched: ${SEARCHED_LOCKFILE_PATHS:-unset})")
              if [[ -n "${SOURCE_MANIFEST_PATH}" && -n "${SOURCE_MANIFEST_SHA256}" ]]; then
                echo "::notice::[POLICY][RELEASE] supplemental manifest evidence present only: ${SOURCE_MANIFEST_PATH} (sha256=${SOURCE_MANIFEST_SHA256})"
              fi
            else
              echo "::notice::[POLICY][RELEASE] lockfile evidence satisfied: ${LOCKFILE_PATH}"
            fi

            if (( ${#failures[@]} > 0 )); then
              for item in "${failures[@]}"; do
                code="${item%%|*}"
                msg="${item#*|}"
                echo "::error::[POLICY][RELEASE][${code}] ${msg}"
              done
              exit 1
            fi

            echo "::notice::[POLICY][RELEASE] corpus evidence posture: PASS"
          else
            echo "::notice::[POLICY][NON-RELEASE] evaluating corpus evidence posture (warnings only)"
            if [[ "${REF_MODE:-mutable}" == "immutable" ]]; then
              echo "::notice::[POLICY][NON-RELEASE] immutable source ref selected: '${EFFECTIVE_REF}'"
            else
              echo "::warning::[POLICY][NON-RELEASE] mutable source ref remains allowed during rollout: '${EFFECTIVE_REF}'"
            fi

            if [[ "${LOCKFILE_PRESENT:-false}" == "true" && -n "${LOCKFILE_PATH}" ]]; then
              echo "::notice::[POLICY][NON-RELEASE] lockfile evidence captured: ${LOCKFILE_PATH}"
            else
              echo "::warning::[POLICY][NON-RELEASE] lockfile evidence missing (allowed in non-release lane; searched: ${SEARCHED_LOCKFILE_PATHS:-unset})"
              if [[ -n "${SOURCE_MANIFEST_PATH}" && -n "${SOURCE_MANIFEST_SHA256}" ]]; then
                echo "::notice::[POLICY][NON-RELEASE] supplemental manifest evidence: ${SOURCE_MANIFEST_PATH} (sha256=${SOURCE_MANIFEST_SHA256})"
              fi
            fi

            echo "::notice::[POLICY][NON-RELEASE] corpus evidence posture: PASS (non-blocking posture unchanged)"
          fi

      - name: Build corpus artifacts integrity metadata
        if: always()
        env:
          LINEAGE_RUNNER_VERSION: ${{ steps.lineage_digests.outputs.runner_version }}
          LINEAGE_RUNNER_CHECKSUM: ${{ steps.lineage_digests.outputs.runner_checksum }}
          CORPUS_MATRIX_SHA256: ${{ steps.lineage_digests.outputs.corpus_matrix_sha256 }}
          LOCKFILE_PATH: ${{ steps.lineage_digests.outputs.lockfile_path }}
          LOCKFILE_SHA256: ${{ steps.lineage_digests.outputs.lockfile_sha256 }}
          SOURCE_MANIFEST_PATH: ${{ steps.lineage_digests.outputs.source_manifest_path }}
          SOURCE_MANIFEST_SHA256: ${{ steps.lineage_digests.outputs.source_manifest_sha256 }}
        run: python3 .ci/scripts/build_governance_artifacts.py build-integrity-metadata
      - name: Validate corpus matrix policy gate
        id: validate_matrix_policy
        if: always() && hashFiles('evidence/validator/test-output/corpus-matrix-report-v1.json') != ''
        run: |
          set -euo pipefail
          args=(
            --matrix "${CORPUS_MATRIX}"
            --lane "${RELEASE_CONTROLLED_LANE}"
            --release-controlled "${RELEASE_CONTROLLED_LANE}"
            --non-blocking "${EVIDENCE_CORPUS_NON_BLOCKING}"
            --non-blocking-owner "${EVIDENCE_CORPUS_NON_BLOCKING_OWNER}"
            --non-blocking-expiry "${EVIDENCE_CORPUS_NON_BLOCKING_EXPIRY}"
            --ref-mode "${{ steps.source_preflight.outputs.ref_mode }}"
            --lockfile-present "${{ steps.lineage_digests.outputs.lockfile_present }}"
            --policy-outcome-json "${POLICY_OUTCOME_JSON}"
          )

          expected_count="${{ steps.lineage_digests.outputs.expected_count }}"
          expected_count_source="${{ steps.lineage_digests.outputs.expected_count_source }}"
          if [[ -z "${expected_count}" ]]; then
            echo "::warning::Expected case count output missing from resolver; defaulting to 0"
            expected_count="0"
          fi
          echo "Resolved expected corpus case count=${expected_count} source=${expected_count_source:-unset}"
          args+=(--expected-case-count "${expected_count}")

          if [[ -n "${CORPUS_MANIFEST_PATH}" || -n "${EXPECTED_CORPUS_MANIFEST_SHA256}" ]]; then
            args+=(--manifest-path "${CORPUS_MANIFEST_PATH}" --expected-manifest-sha256 "${EXPECTED_CORPUS_MANIFEST_SHA256}")
          fi

          echo "validate_corpus_matrix.py invocation (blocking parser enforcement path active)"
          printf '  %q\n' python3 .ci/scripts/validate_corpus_matrix.py "${args[@]}"
          python3 .ci/scripts/validate_corpus_matrix.py "${args[@]}"

      - name: Self-check policy outcome artifact JSON
        if: always()
        env:
          SUMMARY_LANE: ${{ env.RELEASE_CONTROLLED_LANE }}
          SUMMARY_REF_MODE: ${{ steps.source_preflight.outputs.ref_mode }}
          SUMMARY_LOCKFILE_PRESENT: ${{ steps.lineage_digests.outputs.lockfile_present }}
        run: python3 .ci/scripts/validate_governance.py self-check-policy-outcome
      - name: Build deterministic artifact manifest index
        if: always()
        env:
          SUMMARY_REF_MODE: ${{ steps.source_preflight.outputs.ref_mode }}
        run: python3 .ci/scripts/build_governance_artifacts.py build-artifact-manifest
      - name: Enforce artifact role presence by lane
        if: always()
        run: python3 .ci/scripts/validate_governance.py enforce-artifact-role-presence
      - name: Validate cross-artifact linkage integrity
        if: always()
        env:
          SUMMARY_REF_MODE: ${{ steps.source_preflight.outputs.ref_mode }}
        run: python3 .ci/scripts/validate_governance.py validate-linkage-integrity
      - name: Build deterministic reason code index artifact
        if: always()
        run: python3 .ci/scripts/build_governance_artifacts.py build-reason-code-index
      - name: Validate policy drift across governance artifacts
        if: always()
        run: python3 .ci/scripts/validate_governance.py validate-policy-drift
      - name: Validate evidence envelope cohesion
        if: always()
        run: python3 .ci/scripts/validate_governance.py validate-envelope-cohesion
      - name: Validate deterministic replay-proof governance digests
        if: always()
        run: python3 .ci/scripts/validate_governance.py validate-determinism
      - name: Build governance summary artifact
        if: always()
        env:
          GH_RUN_ID: ${{ github.run_id }}
          GH_RUN_ATTEMPT: ${{ github.run_attempt }}
          GH_SHA: ${{ github.sha }}
          GH_REF: ${{ github.ref }}
        run: python3 .ci/scripts/build_governance_artifacts.py build-governance-summary
      - name: Fetch prior governance trends from recent successful runs
        id: fetch_prior_trends
        if: always()
        continue-on-error: true
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPOSITORY: ${{ github.repository }}
          GH_CURRENT_RUN_ID: ${{ github.run_id }}
        run: |
          set -euo pipefail
          mkdir -p "${GOVERNANCE_TRENDS_PRIOR_DIR}"
          lookback="${GOVERNANCE_TRENDS_LOOKBACK_RUNS}"
          echo "Fetching up to ${lookback} prior successful corpus-evidence-ci runs..."

          run_ids="$(gh api \
            "/repos/${GH_REPOSITORY}/actions/workflows/corpus-evidence-ci.yml/runs?status=success&per_page=${lookback}" \
            --jq '.workflow_runs[].id' 2>/dev/null || true)"

          if [[ -z "${run_ids}" ]]; then
            echo "::notice::[TRENDS] No prior successful runs found; will use baseline mode."
            echo "fetched_count=0" >> "$GITHUB_OUTPUT"
            echo "fetch_status=no_prior_runs" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          fetched=0
          for rid in ${run_ids}; do
            if [[ "${rid}" == "${GH_CURRENT_RUN_ID}" ]]; then
              continue
            fi
            artifact_id="$(gh api \
              "/repos/${GH_REPOSITORY}/actions/runs/${rid}/artifacts" \
              --jq '.artifacts[] | select(.name=="corpus-matrix-report-v1") | .id' 2>/dev/null || true)"
            if [[ -z "${artifact_id}" ]]; then
              continue
            fi
            dest="${GOVERNANCE_TRENDS_PRIOR_DIR}/trends-run-${rid}.json"
            tmpzip="$(mktemp)"
            if gh api "/repos/${GH_REPOSITORY}/actions/artifacts/${artifact_id}/zip" > "${tmpzip}" 2>/dev/null; then
              if unzip -p "${tmpzip}" "evidence/validator/test-output/governance-trends-v1.json" > "${dest}" 2>/dev/null; then
                if python3 -c "import json,sys; json.load(open(sys.argv[1]))" "${dest}" 2>/dev/null; then
                  fetched=$((fetched + 1))
                  echo "  fetched trends from run ${rid}"
                else
                  rm -f "${dest}"
                fi
              else
                rm -f "${dest}"
              fi
            fi
            rm -f "${tmpzip}"
          done

          echo "fetched_count=${fetched}" >> "$GITHUB_OUTPUT"
          if (( fetched > 0 )); then
            echo "fetch_status=ok" >> "$GITHUB_OUTPUT"
            echo "::notice::[TRENDS] Fetched ${fetched} prior trend records for historical accumulation."
          else
            echo "fetch_status=no_artifacts" >> "$GITHUB_OUTPUT"
            echo "::notice::[TRENDS] No prior trend artifacts found; will use baseline mode."
          fi
      - name: Build governance trends artifact
        if: always()
        env:
          GH_RUN_ID: ${{ github.run_id }}
          GH_RUN_ATTEMPT: ${{ github.run_attempt }}
          GH_SHA: ${{ github.sha }}
          GH_REF: ${{ github.ref }}
          PRIOR_TRENDS_FETCH_STATUS: ${{ steps.fetch_prior_trends.outputs.fetch_status || 'skipped' }}
          PRIOR_TRENDS_FETCHED_COUNT: ${{ steps.fetch_prior_trends.outputs.fetched_count || '0' }}
        run: python3 .ci/scripts/build_governance_artifacts.py build-governance-trends
      - name: Build governance dashboard artifact
        if: always()
        env:
          GH_RUN_ID: ${{ github.run_id }}
          GH_RUN_ATTEMPT: ${{ github.run_attempt }}
          GH_SHA: ${{ github.sha }}
          GH_REF: ${{ github.ref }}
        run: python3 .ci/scripts/build_governance_artifacts.py build-governance-dashboard
      - name: Sign governance artifacts and validate tamper evidence
        id: sign_and_verify
        if: always()
        env:
          GH_SHA: ${{ github.sha }}
          SIGNING_KEY_SECRET: ${{ secrets.GOVERNANCE_SIGNING_KEY || '' }}
        run: python3 .ci/scripts/sign_and_verify.py
      - name: Upload corpus matrix artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: corpus-matrix-report-v1
          if-no-files-found: warn
          path: |
            ${{ env.CORPUS_MATRIX }}
            ${{ env.CORPUS_OUTPUT_DIR }}/corpus-artifacts-metadata.json
            ${{ env.POLICY_OUTCOME_JSON }}
            ${{ env.ARTIFACT_MANIFEST_JSON }}
            ${{ env.ARTIFACT_LINKAGE_OUTCOME_JSON }}
            ${{ env.REASON_CODES_INDEX_JSON }}
            ${{ env.POLICY_DRIFT_OUTCOME_JSON }}
            ${{ env.ENVELOPE_COHESION_OUTCOME_JSON }}
            ${{ env.DETERMINISM_OUTCOME_JSON }}
            ${{ env.GOVERNANCE_SUMMARY_JSON }}
            ${{ env.GOVERNANCE_TRENDS_JSON }}
            ${{ env.ARTIFACT_SIGNATURES_JSON }}
            ${{ env.GOVERNANCE_DASHBOARD_JSON }}

      - name: Upload corpus summary artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: corpus-summary-md
          if-no-files-found: warn
          path: ${{ env.CORPUS_SUMMARY }}

      - name: Upload per-case corpus reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: corpus-case-reports
          if-no-files-found: warn
          path: ${{ env.CORPUS_REPORTS_DIR }}/**

      - name: Upload runner lockfile evidence (if present)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: corpus-runner-lockfiles
          if-no-files-found: warn
          path: |
            poetry.lock
            requirements*.txt
            _deps/unifyops/poetry.lock
            _deps/unifyops/requirements*.txt

      - name: Build unified evidence envelope inputs (release-controlled)
        if: always() && env.RELEASE_CONTROLLED_LANE == 'true' && hashFiles('evidence/validator/test-output/corpus-matrix-report-v1.json') != ''
        run: |
          set -euo pipefail
          mkdir -p evidence/envelope-inputs
          cp "${CORPUS_MATRIX}" evidence/envelope-inputs/
          cp "${CORPUS_SUMMARY}" evidence/envelope-inputs/
          cp -R "${CORPUS_REPORTS_DIR}" evidence/envelope-inputs/
          for f in \
            "${CORPUS_OUTPUT_DIR}/corpus-artifacts-metadata.json:integrity-metadata.json" \
            "${ARTIFACT_MANIFEST_JSON}:" \
            "${ARTIFACT_LINKAGE_OUTCOME_JSON}:" \
            "${REASON_CODES_INDEX_JSON}:" \
            "${POLICY_DRIFT_OUTCOME_JSON}:" \
            "${ENVELOPE_COHESION_OUTCOME_JSON}:" \
            "${DETERMINISM_OUTCOME_JSON}:" \
            "${GOVERNANCE_SUMMARY_JSON}:" \
            "${GOVERNANCE_TRENDS_JSON}:" \
            "${ARTIFACT_SIGNATURES_JSON}:" \
            "${GOVERNANCE_DASHBOARD_JSON}:"; do
            src="${f%%:*}"
            dest="${f#*:}"
            if [[ -f "${src}" ]]; then
              if [[ -n "${dest}" ]]; then
                cp "${src}" "evidence/envelope-inputs/${dest}"
              else
                cp "${src}" evidence/envelope-inputs/
              fi
            fi
          done
          lockfile_path="${{ steps.lineage_digests.outputs.lockfile_path }}"
          if [[ -n "${lockfile_path}" && -f "${lockfile_path}" ]]; then
            mkdir -p evidence/envelope-inputs/lockfiles
            cp "${lockfile_path}" evidence/envelope-inputs/lockfiles/
          fi
          tar -czf evidence/unified-evidence-envelope-inputs.tgz -C evidence envelope-inputs

      - name: Upload unified evidence envelope inputs (release-controlled)
        uses: actions/upload-artifact@v4
        if: always() && env.RELEASE_CONTROLLED_LANE == 'true'
        with:
          name: unified-evidence-envelope-inputs
          if-no-files-found: warn
          path: evidence/unified-evidence-envelope-inputs.tgz
