name: corpus-evidence-ci

on:
  pull_request:
  push:
    branches:
      - dev
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      UO_EVIDENCE_CORPUS_SOURCE_REPO:
        description: 'Optional override for source repo (org/repo) used by corpus runner checkout.'
        required: false
        type: string
      UO_EVIDENCE_CORPUS_SOURCE_REF:
        description: 'Optional override for source ref (branch/tag/SHA) used by corpus runner checkout.'
        required: false
        default: 'e65ef29bc36ad65b641a903a6b23f488a95c3f3f'
        type: string

jobs:
  corpus-evidence:
    runs-on: ubuntu-latest
    env:
      CORPUS_ROOT: _deps/unifyops/evidence/validator/testdata/evidence-corpus
      CORPUS_OUTPUT_DIR: evidence/validator/test-output
      CORPUS_MATRIX: evidence/validator/test-output/corpus-matrix-report-v1.json
      CORPUS_SUMMARY: evidence/validator/test-output/corpus-summary.md
      CORPUS_REPORTS_DIR: evidence/validator/test-output/corpus-reports
      # Release-controlled lanes: tag pipelines by default.
      RELEASE_CONTROLLED_LANE: ${{ startsWith(github.ref, 'refs/tags/') && 'true' || 'false' }}
      # Temporary rollout toggle (disabled by default).
      EVIDENCE_CORPUS_NON_BLOCKING: ${{ vars.EVIDENCE_CORPUS_NON_BLOCKING || 'false' }}
      EVIDENCE_CORPUS_NON_BLOCKING_OWNER: ${{ vars.EVIDENCE_CORPUS_NON_BLOCKING_OWNER || '' }}
      EVIDENCE_CORPUS_NON_BLOCKING_EXPIRY: ${{ vars.EVIDENCE_CORPUS_NON_BLOCKING_EXPIRY || '' }}
      EXPECTED_CORPUS_CASE_COUNT: ${{ vars.EXPECTED_CORPUS_CASE_COUNT || '' }}
      CORPUS_MANIFEST_PATH: ${{ vars.CORPUS_MANIFEST_PATH || '' }}
      EXPECTED_CORPUS_MANIFEST_SHA256: ${{ vars.EXPECTED_CORPUS_MANIFEST_SHA256 || '' }}
      UO_EVIDENCE_CORPUS_RUNNER_VERSION: "1.0.0"
      # Use source-of-truth runner code from unifyops repo to avoid drift in published packages.
      UO_EVIDENCE_CORPUS_SOURCE_REPO: ${{ inputs.UO_EVIDENCE_CORPUS_SOURCE_REPO || vars.UO_EVIDENCE_CORPUS_SOURCE_REPO || format('{0}/unifyops', github.repository_owner) }}
      UO_EVIDENCE_CORPUS_SOURCE_REF: ${{ inputs.UO_EVIDENCE_CORPUS_SOURCE_REF || vars.UO_EVIDENCE_CORPUS_SOURCE_REF || '' }}
      UO_EVIDENCE_CORPUS_DEFAULT_REF: ${{ vars.UO_EVIDENCE_CORPUS_DEFAULT_REF || 'e65ef29bc36ad65b641a903a6b23f488a95c3f3f' }}
      # Optional for cross-repo private checkout: set secret UO_EVIDENCE_SOURCE_TOKEN with read access.
      UO_EVIDENCE_SOURCE_TOKEN: ${{ secrets.UO_EVIDENCE_SOURCE_TOKEN || '' }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python for corpus runner
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Preflight source repo access/ref for corpus runner checkout
        id: source_preflight
        continue-on-error: true
        env:
          CURRENT_REPO: ${{ github.repository }}
          CURRENT_SHA: ${{ github.sha }}
          INPUT_SOURCE_REF: ${{ inputs.UO_EVIDENCE_CORPUS_SOURCE_REF || '' }}
          VAR_SOURCE_REF: ${{ vars.UO_EVIDENCE_CORPUS_SOURCE_REF || '' }}
          VAR_DEFAULT_REF: ${{ vars.UO_EVIDENCE_CORPUS_DEFAULT_REF || '' }}
        run: |
          set -euo pipefail
          repo="${UO_EVIDENCE_CORPUS_SOURCE_REPO}"
          input_source_ref="${INPUT_SOURCE_REF}"
          var_source_ref="${VAR_SOURCE_REF}"
          var_default_ref="${VAR_DEFAULT_REF}"
          default_ref="${UO_EVIDENCE_CORPUS_DEFAULT_REF:-e65ef29bc36ad65b641a903a6b23f488a95c3f3f}"
          token="${UO_EVIDENCE_SOURCE_TOKEN:-}"
          current_repo="${CURRENT_REPO}"
          release_lane="${RELEASE_CONTROLLED_LANE,,}"

          preflight_ok="false"
          error_type=""
          error_message=""
          effective_ref=""
          ref_mode="mutable"
          cross_repo="false"
          ref_origin=""

          if [[ "${repo}" != "${current_repo}" ]]; then
            cross_repo="true"
          fi

          if [[ -n "${input_source_ref}" ]]; then
            effective_ref="${input_source_ref}"
            ref_origin="input:UO_EVIDENCE_CORPUS_SOURCE_REF"
          elif [[ -n "${var_source_ref}" ]]; then
            effective_ref="${var_source_ref}"
            ref_origin="repo_var:UO_EVIDENCE_CORPUS_SOURCE_REF"
          elif [[ "${cross_repo}" == "true" ]]; then
            effective_ref="${default_ref}"
            if [[ -n "${var_default_ref}" ]]; then
              ref_origin="repo_var:UO_EVIDENCE_CORPUS_DEFAULT_REF"
            else
              ref_origin="default_literal:e65ef29bc36ad65b641a903a6b23f488a95c3f3f"
            fi
          else
            effective_ref="${CURRENT_SHA}"
            ref_origin="same_repo_default:github.sha"
          fi

          if [[ -z "${effective_ref}" ]]; then
            error_type="missing_ref"
            if [[ "${cross_repo}" == "true" ]]; then
              error_message="Unable to resolve cross-repo source ref. Set UO_EVIDENCE_CORPUS_SOURCE_REF input/repo var or define UO_EVIDENCE_CORPUS_DEFAULT_REF (stable branch/tag)."
            else
              error_message="Unable to resolve same-repo source ref from github.sha."
            fi
          fi

          if [[ -z "${error_type}" ]]; then
            if [[ "${effective_ref}" =~ ^refs/tags/.+ ]] || [[ "${effective_ref}" =~ ^[A-Fa-f0-9]{7,40}$ ]] || [[ "${effective_ref}" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+([-.].*)?$ ]]; then
              ref_mode="immutable"
            fi

            if [[ "${release_lane}" == "true" && "${ref_mode}" != "immutable" ]]; then
              error_type="mutable_ref_disallowed"
              error_message="Release-controlled lane requires immutable source ref (tag or commit SHA), got '${effective_ref}'."
            elif [[ "${release_lane}" != "true" && "${ref_mode}" != "immutable" ]]; then
              echo "::warning::Selected source ref '${effective_ref}' is mutable in a non-release lane. Prefer a tag or commit SHA for immutable provenance."
            fi
          fi

          if [[ -z "${error_type}" && "${cross_repo}" == "true" && -z "${token}" ]]; then
            error_type="missing_cross_repo_token"
            error_message="Cross-repo source checkout requires secrets.UO_EVIDENCE_SOURCE_TOKEN with read access to '${repo}'."
          fi

          token_present="false"
          repo_endpoint_status="not_checked"
          ref_check_status="not_checked"
          if [[ -n "${token}" ]]; then
            token_present="true"
          fi

          if [[ -z "${error_type}" ]]; then
            auth_args=(-H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28")
            if [[ -n "${token}" ]]; then
              auth_args+=(-H "Authorization: Bearer ${token}")
            fi

            api_base="https://api.github.com/repos/${repo}"
            repo_resp_file="$(mktemp)"
            set +e
            repo_endpoint_status="$(curl -sS -L -o "${repo_resp_file}" -w '%{http_code}' "${auth_args[@]}" "${api_base}")"
            curl_rc=$?
            set -e

            if [[ ${curl_rc} -ne 0 ]]; then
              error_type="checkout_preflight_failed"
              error_message="Unable to validate source repo '${repo}' via GitHub API (transport error)."
            elif [[ "${repo_endpoint_status}" == "200" ]]; then
              :
            elif [[ "${repo_endpoint_status}" == "401" || "${repo_endpoint_status}" == "403" ]]; then
              error_type="auth_denied"
              error_message="Authentication denied for source repo '${repo}'. Verify UO_EVIDENCE_SOURCE_TOKEN read access."
            elif [[ "${repo_endpoint_status}" == "404" ]]; then
              error_type="repo_not_found"
              error_message="Source repo '${repo}' was not found. Verify UO_EVIDENCE_CORPUS_SOURCE_REPO value."
            else
              error_type="checkout_preflight_failed"
              error_message="Unable to validate source repo '${repo}' via GitHub API (status=${repo_endpoint_status})."
            fi
            rm -f "${repo_resp_file}"

            if [[ -z "${error_type}" ]]; then
              ref_endpoint=""
              if [[ "${effective_ref}" =~ ^refs/tags/(.+)$ ]]; then
                ref_endpoint="${api_base}/git/ref/tags/${BASH_REMATCH[1]}"
              elif [[ "${effective_ref}" =~ ^[A-Fa-f0-9]{7,40}$ ]]; then
                ref_endpoint="${api_base}/commits/${effective_ref}"
              elif [[ "${effective_ref}" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+([-.].*)?$ ]]; then
                ref_endpoint="${api_base}/git/ref/tags/${effective_ref}"
              else
                ref_endpoint="${api_base}/git/ref/heads/${effective_ref}"
              fi

              ref_resp_file="$(mktemp)"
              set +e
              ref_check_status="$(curl -sS -L -o "${ref_resp_file}" -w '%{http_code}' "${auth_args[@]}" "${ref_endpoint}")"
              curl_rc=$?
              set -e

              if [[ ${curl_rc} -ne 0 ]]; then
                error_type="checkout_preflight_failed"
                error_message="Unable to validate source ref '${effective_ref}' in repo '${repo}' via GitHub API (transport error)."
              elif [[ "${ref_check_status}" == "200" ]]; then
                preflight_ok="true"
              elif [[ "${ref_check_status}" == "404" ]]; then
                error_type="ref_missing"
                error_message="Configured ref '${effective_ref}' was not found in source repo '${repo}'."
              elif [[ "${ref_check_status}" == "401" || "${ref_check_status}" == "403" ]]; then
                error_type="auth_denied"
                error_message="Authentication denied for source repo '${repo}'. Verify UO_EVIDENCE_SOURCE_TOKEN read access."
              else
                error_type="checkout_preflight_failed"
                error_message="Unable to validate source ref '${effective_ref}' in repo '${repo}' via GitHub API (status=${ref_check_status})."
              fi
              rm -f "${ref_resp_file}"
            fi
          fi

          echo "Source selection: repo='${repo}' cross_repo='${cross_repo}' ref='${effective_ref:-<unset>}' origin='${ref_origin:-<unset>}' mode='${ref_mode}' release_lane='${release_lane}' token_present='${token_present:-false}' repo_endpoint_status='${repo_endpoint_status:-not_checked}' ref_check_status='${ref_check_status:-not_checked}'"

          echo "preflight_ok=${preflight_ok}" >> "$GITHUB_OUTPUT"
          echo "error_type=${error_type}" >> "$GITHUB_OUTPUT"
          echo "error_message=${error_message}" >> "$GITHUB_OUTPUT"
          echo "effective_ref=${effective_ref}" >> "$GITHUB_OUTPUT"
          echo "ref_mode=${ref_mode}" >> "$GITHUB_OUTPUT"
          echo "cross_repo=${cross_repo}" >> "$GITHUB_OUTPUT"
          echo "ref_origin=${ref_origin}" >> "$GITHUB_OUTPUT"
          echo "token_present=${token_present:-false}" >> "$GITHUB_OUTPUT"
          echo "repo_endpoint_status=${repo_endpoint_status:-not_checked}" >> "$GITHUB_OUTPUT"
          echo "ref_check_status=${ref_check_status:-not_checked}" >> "$GITHUB_OUTPUT"

          if [[ "${preflight_ok}" == "true" ]]; then
            echo "Source preflight passed for ${repo}@${effective_ref} (mode=${ref_mode})."
          else
            echo "::warning::Source preflight failed (${error_type}): ${error_message}"
            exit 1
          fi

      - name: Checkout unifyops source for corpus runner
        id: source_checkout
        if: always() && steps.source_preflight.outputs.preflight_ok == 'true'
        continue-on-error: true
        uses: actions/checkout@v4
        with:
          repository: ${{ env.UO_EVIDENCE_CORPUS_SOURCE_REPO }}
          ref: ${{ steps.source_preflight.outputs.effective_ref }}
          path: _deps/unifyops
          token: ${{ env.UO_EVIDENCE_CORPUS_SOURCE_REPO == github.repository && github.token || secrets.UO_EVIDENCE_SOURCE_TOKEN }}

      - name: Install evidence corpus runner dependency (local source)
        id: runner_install
        if: always() && steps.source_preflight.outputs.preflight_ok == 'true' && steps.source_checkout.outcome == 'success'
        continue-on-error: true
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          # Local source install is required because published 1.0.0 package variants can import app.config,
          # which is unavailable in this infra workflow context.
          python -m pip install -e _deps/unifyops/shared/unifyops_core
          # Required for unifyops_core schema import path (pydantic email validation).
          python -m pip install email-validator

      - name: Ensure corpus output directories exist
        run: mkdir -p "${CORPUS_OUTPUT_DIR}" "${CORPUS_REPORTS_DIR}"

      - name: Run evidence corpus runner (local source)
        id: corpus_runner
        if: always() && steps.source_preflight.outputs.preflight_ok == 'true' && steps.source_checkout.outcome == 'success' && steps.runner_install.outcome == 'success'
        continue-on-error: true
        run: |
          set -euo pipefail
          python -m unifyops_core.evidence.validator.tools.corpus_runner \
            --corpus-root "${CORPUS_ROOT}" \
            --matrix-out "${CORPUS_MATRIX}" \
            --reports-dir "${CORPUS_REPORTS_DIR}" \
            --summary-md-out "${CORPUS_SUMMARY}"

      - name: Enforce runner/matrix gate semantics
        if: always()
        env:
          PRECHECK_OUTCOME: ${{ steps.source_preflight.outcome }}
          PRECHECK_OK: ${{ steps.source_preflight.outputs.preflight_ok }}
          PRECHECK_ERROR_TYPE: ${{ steps.source_preflight.outputs.error_type }}
          PRECHECK_ERROR_MESSAGE: ${{ steps.source_preflight.outputs.error_message }}
          SOURCE_CHECKOUT_OUTCOME: ${{ steps.source_checkout.outcome }}
          RUNNER_INSTALL_OUTCOME: ${{ steps.runner_install.outcome }}
          RUNNER_OUTCOME: ${{ steps.corpus_runner.outcome }}
        run: |
          set -euo pipefail
          non_blocking="${EVIDENCE_CORPUS_NON_BLOCKING,,}"
          prereq_error=""

          if [[ "${PRECHECK_OK:-false}" != "true" ]]; then
            prereq_error="source checkout preflight failed (${PRECHECK_ERROR_TYPE:-unknown}): ${PRECHECK_ERROR_MESSAGE:-preflight did not succeed}"
          elif [[ "${SOURCE_CHECKOUT_OUTCOME:-skipped}" != "success" ]]; then
            prereq_error="source checkout step failed (outcome=${SOURCE_CHECKOUT_OUTCOME:-unknown})."
          elif [[ "${RUNNER_INSTALL_OUTCOME:-skipped}" != "success" ]]; then
            prereq_error="runner dependency install step failed (outcome=${RUNNER_INSTALL_OUTCOME:-unknown})."
          elif [[ "${RUNNER_OUTCOME:-skipped}" != "success" ]]; then
            prereq_error="corpus runner execution failed (outcome=${RUNNER_OUTCOME:-unknown})."
          fi

          if [[ -n "${prereq_error}" ]]; then
            if [[ "${non_blocking}" == "true" ]]; then
              echo "::warning::[NON-BLOCKING EVIDENCE CORPUS] ${prereq_error} Downstream validation is skipped."
            else
              echo "::error::Evidence corpus gate failed: ${prereq_error}"
              exit 1
            fi
          fi

          if [[ ! -s "${CORPUS_MATRIX}" ]]; then
            if [[ "${non_blocking}" == "true" ]]; then
              echo "::warning::[NON-BLOCKING EVIDENCE CORPUS] matrix artifact missing at ${CORPUS_MATRIX}; digest/lineage/policy validation is skipped."
            else
              echo "::error::Evidence corpus gate failed: required matrix artifact missing at ${CORPUS_MATRIX}."
              exit 1
            fi
          fi

      - name: Emit corpus matrix SHA-256
        id: matrix_digest
        if: always() && hashFiles('evidence/validator/test-output/corpus-matrix-report-v1.json') != ''
        run: |
          set -euo pipefail
          digest="$(sha256sum "${CORPUS_MATRIX}" | awk '{print $1}')"
          echo "corpus_matrix_sha256=${digest}" >> "$GITHUB_OUTPUT"
          echo "corpus_matrix_sha256=${digest}"

      - name: Hydrate corpus matrix lineage defaults
        if: always() && hashFiles('evidence/validator/test-output/corpus-matrix-report-v1.json') != ''
        env:
          GH_SHA: ${{ github.sha }}
          GH_RUN_ID: ${{ github.run_id }}
          GH_RUN_ATTEMPT: ${{ github.run_attempt }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import hashlib
          import importlib.util
          import json
          import os
          import subprocess
          from pathlib import Path

          matrix = Path(os.environ['CORPUS_MATRIX'])
          data = json.loads(matrix.read_text(encoding='utf-8'))
          lineage = data.get('lineage')
          if not isinstance(lineage, dict):
              lineage = {}
              data['lineage'] = lineage

          def nonempty(value):
              return isinstance(value, str) and value.strip() != ''

          def set_default(key, value):
              if nonempty(lineage.get(key)):
                  return
              lineage[key] = value

          gh_sha = os.environ.get('GH_SHA', '').strip()

          source_commit_sha = gh_sha
          try:
              dep_sha = subprocess.check_output(
                  ['git', '-C', '_deps/unifyops', 'rev-parse', 'HEAD'],
                  text=True,
                  stderr=subprocess.DEVNULL,
              ).strip()
              if dep_sha:
                  source_commit_sha = dep_sha
          except Exception:
              pass

          release_artifact_id = f"{os.environ.get('GH_RUN_ID', '').strip()}-{os.environ.get('GH_RUN_ATTEMPT', '').strip()}".strip('-')
          release_artifact_checksum = hashlib.sha256(gh_sha.encode('utf-8')).hexdigest() if gh_sha else ''
          runner_version = os.environ.get('UO_EVIDENCE_CORPUS_RUNNER_VERSION', '').strip() or '1.0.0'

          runner_candidates = [
              Path('_deps/unifyops/shared/unifyops_core/src/unifyops_core/evidence/validator/tools/corpus_runner.py'),
              Path('_deps/unifyops/shared/unifyops_core/unifyops_core/evidence/validator/tools/corpus_runner.py'),
              Path('shared/unifyops_core/src/unifyops_core/evidence/validator/tools/corpus_runner.py'),
              Path('shared/unifyops_core/unifyops_core/evidence/validator/tools/corpus_runner.py'),
          ]
          spec = importlib.util.find_spec('unifyops_core.evidence.validator.tools.corpus_runner')
          if spec and spec.origin:
              module_path = Path(spec.origin)
              if module_path.suffix == '.pyc':
                  module_path = Path(str(module_path).replace('/__pycache__/', '/')).with_suffix('.py')
              runner_candidates.insert(0, module_path)

          runner_checksum = ''
          for candidate in runner_candidates:
              if candidate.is_file():
                  runner_checksum = hashlib.sha256(candidate.read_bytes()).hexdigest()
                  break

          set_default('source_commit_sha', source_commit_sha)
          set_default('release_artifact_id', release_artifact_id)
          set_default('release_artifact_checksum', release_artifact_checksum)
          set_default('runner_version', runner_version)
          set_default('runner_checksum', runner_checksum)

          matrix.write_text(json.dumps(data, indent=2, sort_keys=True) + '\n', encoding='utf-8')
          print('hydrated lineage defaults (missing-only)')
          PY


      - name: Extract required lineage outputs
        id: lineage
        if: always() && hashFiles('evidence/validator/test-output/corpus-matrix-report-v1.json') != ''
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json
          from pathlib import Path

          matrix = Path("evidence/validator/test-output/corpus-matrix-report-v1.json")
          data = json.loads(matrix.read_text(encoding="utf-8"))
          lineage = data.get("lineage", {})

          import os
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as out:
              for key in (
                  "source_commit_sha",
                  "release_artifact_id",
                  "release_artifact_checksum",
                  "runner_version",
                  "runner_checksum",
              ):
                  value = str(lineage.get(key, "")).strip()
                  out.write(f"{key}={value}\\n")
          PY

      - name: Emit runner lineage audit fields
        if: always() && hashFiles('evidence/validator/test-output/corpus-matrix-report-v1.json') != ''
        run: |
          set -euo pipefail
          runner_version="${{ steps.lineage.outputs.runner_version }}"
          if [[ -z "${runner_version}" ]]; then
            runner_version="${UO_EVIDENCE_CORPUS_RUNNER_VERSION:-1.0.0}"
          fi
          echo "runner_version=${runner_version}"
          echo "runner_checksum=${{ steps.lineage.outputs.runner_checksum }}"
          echo "corpus_matrix_sha256=${{ steps.matrix_digest.outputs.corpus_matrix_sha256 }}"

      - name: Emit lockfile SHA-256 (if present)
        id: lockfile_digest
        if: always()
        run: |
          set -euo pipefail
          shopt -s nullglob
          lockfiles=(poetry.lock requirements*.txt _deps/unifyops/poetry.lock _deps/unifyops/requirements*.txt)
          IFS=$'\n' lockfiles=($(printf '%s\n' "${lockfiles[@]}" | sort -u))
          unset IFS

          valid_lockfiles=()
          for lf in "${lockfiles[@]}"; do
            if [[ -f "${lf}" ]]; then
              valid_lockfiles+=("${lf}")
            fi
          done

          manifest_path="_deps/unifyops/shared/unifyops_core/pyproject.toml"
          manifest_sha=""
          if [[ -f "${manifest_path}" ]]; then
            manifest_sha="$(sha256sum "${manifest_path}" | awk '{print $1}')"
            echo "source_manifest_path=${manifest_path}" >> "$GITHUB_OUTPUT"
            echo "source_manifest_sha256=${manifest_sha}" >> "$GITHUB_OUTPUT"
          else
            echo "source_manifest_path=" >> "$GITHUB_OUTPUT"
            echo "source_manifest_sha256=" >> "$GITHUB_OUTPUT"
          fi

          if (( ${#valid_lockfiles[@]} == 0 )); then
            searched_paths="$(printf '%s, ' "${lockfiles[@]}" | sed 's/, $//')"
            echo "::warning::No lockfile evidence present; searched paths: ${searched_paths}."
            if [[ -n "${manifest_sha}" ]]; then
              echo "Supplemental source dependency manifest detected: ${manifest_path} (sha256=${manifest_sha})"
            fi
            echo "lockfile_path=" >> "$GITHUB_OUTPUT"
            echo "lockfile_sha256=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          primary="${valid_lockfiles[0]}"
          primary_sha="$(sha256sum "${primary}" | awk '{print $1}')"
          echo "lockfile_path=${primary}" >> "$GITHUB_OUTPUT"
          echo "lockfile_sha256=${primary_sha}" >> "$GITHUB_OUTPUT"
          echo "lockfile_path=${primary}"
          echo "lockfile_sha256=${primary_sha}"

          for lf in "${valid_lockfiles[@]}"; do
            if [[ -f "${lf}" ]]; then
              sha="$(sha256sum "${lf}" | awk '{print $1}')"
              echo "lockfile_sha256[${lf}]=${sha}"
            else
              echo "::warning::Lockfile disappeared before digesting: ${lf}"
            fi
          done

      - name: Build corpus artifacts integrity metadata
        if: always()
        run: |
          set -euo pipefail
          mkdir -p "${CORPUS_OUTPUT_DIR}"
          python3 - <<'PY'
          import hashlib
          import importlib.util
          import json
          import os
          from pathlib import Path

          out = Path(os.environ['CORPUS_OUTPUT_DIR']) / 'corpus-artifacts-metadata.json'

          configured_runner_version = os.environ.get('UO_EVIDENCE_CORPUS_RUNNER_VERSION', '').strip() or '1.0.0'
          lineage_runner_version = '${{ steps.lineage.outputs.runner_version }}'.strip()
          runner_version = lineage_runner_version or configured_runner_version

          runner_candidates = [
              Path('_deps/unifyops/shared/unifyops_core/src/unifyops_core/evidence/validator/tools/corpus_runner.py'),
              Path('_deps/unifyops/shared/unifyops_core/unifyops_core/evidence/validator/tools/corpus_runner.py'),
          ]
          spec = importlib.util.find_spec('unifyops_core.evidence.validator.tools.corpus_runner')
          if spec and spec.origin:
              module_path = Path(spec.origin)
              if module_path.suffix == '.pyc':
                  module_path = Path(str(module_path).replace('/__pycache__/', '/')).with_suffix('.py')
              runner_candidates.insert(0, module_path)

          runner_checksum = ''
          for candidate in runner_candidates:
              if candidate.is_file():
                  runner_checksum = hashlib.sha256(candidate.read_bytes()).hexdigest()
                  break

          lineage_runner_checksum = '${{ steps.lineage.outputs.runner_checksum }}'.strip()
          if not runner_checksum:
              runner_checksum = lineage_runner_checksum

          data = {
              'corpus_matrix_path': os.environ.get('CORPUS_MATRIX', ''),
              'corpus_matrix_sha256': '${{ steps.matrix_digest.outputs.corpus_matrix_sha256 }}',
              'runner_version': runner_version,
              'runner_checksum': runner_checksum,
              'lockfile_path': '${{ steps.lockfile_digest.outputs.lockfile_path }}',
              'lockfile_sha256': '${{ steps.lockfile_digest.outputs.lockfile_sha256 }}',
              'source_manifest_path': '${{ steps.lockfile_digest.outputs.source_manifest_path }}',
              'source_manifest_sha256': '${{ steps.lockfile_digest.outputs.source_manifest_sha256 }}',
          }
          out.write_text(json.dumps(data, indent=2, sort_keys=True) + '\n', encoding='utf-8')
          print(f'wrote metadata: {out}')
          PY

      - name: Validate corpus matrix policy gate
        if: always() && hashFiles('evidence/validator/test-output/corpus-matrix-report-v1.json') != ''
        run: |
          set -euo pipefail
          args=(
            --matrix "${CORPUS_MATRIX}"
            --release-controlled "${RELEASE_CONTROLLED_LANE}"
            --non-blocking "${EVIDENCE_CORPUS_NON_BLOCKING}"
            --non-blocking-owner "${EVIDENCE_CORPUS_NON_BLOCKING_OWNER}"
            --non-blocking-expiry "${EVIDENCE_CORPUS_NON_BLOCKING_EXPIRY}"
          )

          expected_count="${EXPECTED_CORPUS_CASE_COUNT}"
          if [[ -z "${expected_count}" ]]; then
            if [[ ! -d "${CORPUS_ROOT}" ]]; then
              if [[ "${EVIDENCE_CORPUS_NON_BLOCKING,,}" == "true" ]]; then
                echo "::warning::[NON-BLOCKING EVIDENCE CORPUS] Corpus root not found at ${CORPUS_ROOT}; cannot auto-derive expected corpus case count."
                expected_count="0"
              else
                echo "::error::Evidence corpus gate failed: corpus root not found at ${CORPUS_ROOT}; unable to derive expected case count."
                exit 1
              fi
            else
              expected_count="$(find "${CORPUS_ROOT}" -type f -name 'expected-result.json' | wc -l | tr -d '[:space:]')"
              echo "Auto-derived expected corpus case count=${expected_count} from ${CORPUS_ROOT}"
            fi
          else
            echo "Using configured EXPECTED_CORPUS_CASE_COUNT=${expected_count}"
          fi
          args+=(--expected-case-count "${expected_count}")

          if [[ -n "${CORPUS_MANIFEST_PATH}" || -n "${EXPECTED_CORPUS_MANIFEST_SHA256}" ]]; then
            args+=(--manifest-path "${CORPUS_MANIFEST_PATH}" --expected-manifest-sha256 "${EXPECTED_CORPUS_MANIFEST_SHA256}")
          fi

          echo "validate_corpus_matrix.py invocation (blocking parser enforcement path active)"
          printf '  %q\n' python3 .ci/scripts/validate_corpus_matrix.py "${args[@]}"
          python3 .ci/scripts/validate_corpus_matrix.py "${args[@]}"

      - name: Upload corpus matrix artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: corpus-matrix-report-v1
          if-no-files-found: warn
          path: |
            ${{ env.CORPUS_MATRIX }}
            ${{ env.CORPUS_OUTPUT_DIR }}/corpus-artifacts-metadata.json

      - name: Upload corpus summary artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: corpus-summary-md
          if-no-files-found: warn
          path: ${{ env.CORPUS_SUMMARY }}

      - name: Upload per-case corpus reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: corpus-case-reports
          if-no-files-found: warn
          path: ${{ env.CORPUS_REPORTS_DIR }}/**

      - name: Upload runner lockfile evidence (if present)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: corpus-runner-lockfiles
          if-no-files-found: warn
          path: |
            poetry.lock
            requirements*.txt
            _deps/unifyops/poetry.lock
            _deps/unifyops/requirements*.txt

      - name: Build unified evidence envelope inputs (release-controlled)
        if: always() && env.RELEASE_CONTROLLED_LANE == 'true' && hashFiles('evidence/validator/test-output/corpus-matrix-report-v1.json') != ''
        run: |
          set -euo pipefail
          mkdir -p evidence/envelope-inputs
          cp "${CORPUS_MATRIX}" evidence/envelope-inputs/
          cp "${CORPUS_SUMMARY}" evidence/envelope-inputs/
          cp -R "${CORPUS_REPORTS_DIR}" evidence/envelope-inputs/
          if [[ -f "${CORPUS_OUTPUT_DIR}/corpus-artifacts-metadata.json" ]]; then
            cp "${CORPUS_OUTPUT_DIR}/corpus-artifacts-metadata.json" evidence/envelope-inputs/integrity-metadata.json
          fi
          if [[ -n "${{ steps.lockfile_digest.outputs.lockfile_path }}" && -f "${{ steps.lockfile_digest.outputs.lockfile_path }}" ]]; then
            mkdir -p evidence/envelope-inputs/lockfiles
            cp "${{ steps.lockfile_digest.outputs.lockfile_path }}" evidence/envelope-inputs/lockfiles/
          fi
          tar -czf evidence/unified-evidence-envelope-inputs.tgz -C evidence envelope-inputs

      - name: Upload unified evidence envelope inputs (release-controlled)
        uses: actions/upload-artifact@v4
        if: always() && env.RELEASE_CONTROLLED_LANE == 'true'
        with:
          name: unified-evidence-envelope-inputs
          if-no-files-found: warn
          path: evidence/unified-evidence-envelope-inputs.tgz
